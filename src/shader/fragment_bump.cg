void main(	in float4 colorIN : COLOR0,
		in float2 texCoords : TEXCOORD0,		// The texture map's texcoords
		in float2 normalCoords : TEXCOORD1,		// The normal map's texcoords
		in float3 vLightVector : TEXCOORD2,		// The transformed light vector (in tangent space)

		out float4 colorOUT : COLOR0,			// The final color of the current pixel

		uniform sampler2D baseTexture : TEXUNIT0,	// The whole rock texture map
		uniform sampler2D normalTexture : TEXUNIT1,	// The whole normal map
		uniform float3 fLightDiffuseColor)		// The diffuse color of the light source
{
	// We must remember to normalize the light vector as it's linearly interpolated across the surface,
	// which in turn means the length of the vector will change as we interpolate
	vLightVector = normalize(vLightVector);

	// Since the normals in the normal map are in the (color) range [0, 1] we need to uncompress them
	// to "real" normal (vector) directions.
	// Decompress vector ([0, 1] -> [-1, 1])
	float3 vNormal = 2.0f * (tex2D(normalTexture, normalCoords).rgb - 0.5f);
	
	// Calculate the diffuse component and store it as the final color in 'colorOUT'
	// The diffuse component is defined as: I = Dl * Dm * clamp(L¥N, 0, 1)
	// saturate() works just like clamp() except that it implies a clamping between [0;1]
	colorOUT.rgb = fLightDiffuseColor * tex2D(baseTexture, texCoords).rgb * saturate(dot(vLightVector, vNormal));
}