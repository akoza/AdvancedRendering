void main(	in float4 position : POSITION,			// The position of the current vertex. This parameter is required by CG in a vertex shader!
		in float2 texCoords : TEXCOORD0, 		// To send the data to the shader we use glMultiTexCoord2fARB(GL_TEXTURE0_ARB, ...)
		in float3 vTangent : TEXCOORD1,			// To send the data to the shader we use glMultiTexCoord3fARB(GL_TEXTURE1_ARB, ...)
		in float3 vBinormal : TEXCOORD2,		// To send the data to the shader we use glMultiTexCoord3fARB(GL_TEXTURE2_ARB, ...)
		in float3 vNormal : TEXCOORD3,			// To send the data to the shader we use glMultiTexCoord3fARB(GL_TEXTURE3_ARB, ...)

		out float4 positionOUT : POSITION,		// Send the transformed vertex position on to the fragment shader
		out float2 texCoordsOUT : TEXCOORD0,		// Send the texture map's texcoords to the fragment shader
		out float2 normalCoordsOUT : TEXCOORD1,		// Send the normal map's texcoords to the fragment shader
		out float3 vLightVector : TEXCOORD2, 		// Send the transformed light vector to the fragment shader

		uniform float4x4 modelViewProjMatrix,	// The concatenated modelview and projection matrix
		uniform float3 lightPosition) 		// The light sphere's position in object space
{
	// Calculate the light vector
	vLightVector = lightPosition - position.xyz;

	// Transform the light vector from object space into tangent space
	float3x3 TBNMatrix = float3x3(vTangent, vBinormal, vNormal);
	vLightVector.xyz = mul(TBNMatrix, vLightVector);
	
	// Transform the current vertex from object space to clip space, since OpenGL isn't doing it for us
	// as long we're using a vertex shader
	positionOUT = mul(modelViewProjMatrix, position);
	
	// Send the texture map coords and normal map coords to the fragment shader
	texCoordsOUT = texCoords;
	normalCoordsOUT = texCoords;
}